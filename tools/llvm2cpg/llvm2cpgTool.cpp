#include "FileType.h"
#include <llvm/Support/CommandLine.h>
#include <llvm/Support/FileSystem.h>
#include <llvm/Support/Path.h>
#include <llvm2cpg/CPG/BitcodeLoader.h>
#include <llvm2cpg/CPG/CPG.h>
#include <llvm2cpg/CPG/Version.h>
#include <llvm2cpg/CPGWriter/CPGProtoWriter.h>
#include <llvm2cpg/Logger/CPGLogger.h>
#include <set>
#include <sstream>
#include <string>

llvm::cl::OptionCategory CPGProtoWriterCategory("llvm2cpg");

llvm::cl::list<std::string> BitcodePaths(
    llvm::cl::Positional, llvm::cl::OneOrMore,
    llvm::cl::desc("Input: maybe one or more of any .bc, .ll, executables, or directories"),
    llvm::cl::cat(CPGProtoWriterCategory));

llvm::cl::opt<std::string>
    OutputDirectory("output-dir", llvm::cl::Optional,
                    llvm::cl::desc("Where to store cpg.bin.zip (defaults to '.')"),
                    llvm::cl::cat(CPGProtoWriterCategory), llvm::cl::init("."));

llvm::cl::opt<std::string> OutputName("output-name", llvm::cl::Optional,
                                      llvm::cl::desc("Output filename (defaults to 'cpg.bin.zip')"),
                                      llvm::cl::cat(CPGProtoWriterCategory),
                                      llvm::cl::init("cpg.bin.zip"));

llvm::cl::opt<std::string>
    Output("output", llvm::cl::Optional,
           llvm::cl::desc("Output file path. Overrides --output-dir and --output-name"),
           llvm::cl::cat(CPGProtoWriterCategory));

llvm::cl::opt<bool>
    APInliner("inline", llvm::cl::Optional,
              llvm::cl::desc("Enable inlining of access paths (loads, pointer arithmetic)"),
              llvm::cl::cat(CPGProtoWriterCategory), llvm::cl::init(true));

llvm::cl::opt<bool> InlineStrings("inline-strings", llvm::cl::Optional,
                                  llvm::cl::desc("Enable global strings inlining"),
                                  llvm::cl::cat(CPGProtoWriterCategory), llvm::cl::init(true));

llvm::cl::opt<bool> SimplifyBC("simplify", llvm::cl::Optional,
                               llvm::cl::desc("Enable simplification of bitcode"),
                               llvm::cl::cat(CPGProtoWriterCategory), llvm::cl::init(false));

llvm::cl::opt<bool> StrictMode("strict-mode", llvm::cl::Optional,
                               llvm::cl::desc("Treat warnings as fatal errors"),
                               llvm::cl::cat(CPGProtoWriterCategory), llvm::cl::init(false));

static std::set<std::string> getInputFilePaths(llvm2cpg::CPGLogger &logger) {
  std::set<std::string> files;

  std::vector<std::string> worklist;

  for (size_t i = 0; i < BitcodePaths.size(); i++) {
    std::string path = BitcodePaths[i];
    if (llvm::sys::fs::is_directory(path)) {
      logger.uiInfo("Scanning directory for bitcode files: " + path);
      std::error_code errorCode;
      llvm::sys::fs::recursive_directory_iterator end;
      llvm::sys::fs::recursive_directory_iterator dir(llvm::Twine(path), errorCode);
      while (!errorCode && dir != end) {
        worklist.push_back(dir->path());
        dir.increment(errorCode);
      }
      if (errorCode) {
        logger.uiWarning("Skipping " + path + "Reason: " + errorCode.message());
      }
    } else {
      worklist.push_back(path);
    }
  }

  for (const std::string &path : worklist) {
    if (llvm::sys::fs::is_directory(path)) {
      continue;
    }

    /// Doesn't seem to be small, but the API forces us to use this type here
    llvm::SmallString<4096> realPath;
    std::error_code error = llvm::sys::fs::real_path(path, realPath);
    if (error) {
      logger.uiWarning("Skipping " + path + " Reason:" + error.message());
      continue;
    }

    std::string filePath = realPath.str();
    llvm2cpg::FileType type = getFileType(logger, filePath);
    switch (type) {
    case llvm2cpg::FileType::Unsupported:
      break;

    case llvm2cpg::FileType::Bitcode:
    case llvm2cpg::FileType::Binary:
      files.insert(filePath);
      break;

    case llvm2cpg::FileType::LLVM_IR:
      if (llvm::StringRef(filePath).endswith(".ll")) {
        files.insert(filePath);
      }
      break;
    }
  }

  return files;
}

int main(int argc, char **argv) {
  llvm::cl::SetVersionPrinter(llvm2cpg::printVersionInformationStream);
  llvm::cl::HideUnrelatedOptions(CPGProtoWriterCategory);
  llvm::cl::ParseCommandLineOptions(argc, argv);

  llvm2cpg::CPGLogger logger(StrictMode.getValue());
  logger.uiInfo(std::string("More details: ") + logger.getLogPath());

  std::stringstream logIntro;
  logIntro << "Generated by llvm2cpg (" << llvm2cpg::llvm2cpgVersionString() << " / "
           << llvm2cpg::llvm2cpgCommitString() << ")";
  logger.logInfo(logIntro.str());

  llvm2cpg::BitcodeLoader loader(logger);
  std::vector<std::unique_ptr<llvm::Module>> modules;

  llvm2cpg::CPG cpg(logger, APInliner.getValue(), SimplifyBC.getValue(), InlineStrings.getValue());
  for (const std::string &path : getInputFilePaths(logger)) {
    logger.uiInfo(std::string("Loading ") + path);
    llvm2cpg::FileType type = getFileType(logger, path);
    switch (type) {
    case llvm2cpg::FileType::Unsupported: {
      logger.logWarning(std::string("Skipping unsupported file ") + path);
    } break;
    case llvm2cpg::FileType::Bitcode: {
      logger.logInfo(std::string("Parsing bitcode file ") + path);
      std::unique_ptr<llvm::Module> module = loader.loadBitcode(path);
      modules.push_back(std::move(module));
    } break;
    case llvm2cpg::FileType::Binary: {
      logger.logInfo(std::string("Attempting to extract bitcode from ") + path);
      for (std::unique_ptr<llvm::Module> &module : loader.extractBitcode(path)) {
        modules.push_back(std::move(module));
      }
    } break;
    case llvm2cpg::FileType::LLVM_IR: {
      logger.logInfo(std::string("Parsing IR file ") + path);
      std::unique_ptr<llvm::Module> module = loader.loadIR(path);
      if (module) {
        modules.push_back(std::move(module));
      }
    } break;
    }
  }
  for (std::unique_ptr<llvm::Module> &module : modules) {
    cpg.addBitcode(module.get());
  }

  std::string output = Output.getValue();
  if (output.empty()) {
    output = OutputDirectory.getValue() + '/' + OutputName.getValue();
  }

  llvm2cpg::CPGProtoWriter writer(logger, output);
  writer.writeCpg(cpg);

  logger.uiInfo("Shutting down");
  return 0;
}
