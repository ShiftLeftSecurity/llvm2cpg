# llvm2cpg

This project is intended to produce the code property graph out of a LLVM Bitcode files.

## Build

Requirements for the build:

 - clang
 - libzip-dev
 - libtinfo-dev
 - LLVM
 - cmake
 - ninja-build (optional, but recommended)

So far, it was only tested on Ubuntu against LLVM 8.
Recommended way to install LLVM is to download a precompiled binary from [LLVM Releases page](http://releases.llvm.org).
Example:

```
sudo mkdir /opt/llvm
sudo chown -R `whoami`:`whoami` /opt/llvm
cd /opt/llvm
wget http://releases.llvm.org/8.0.0/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz
tar xf clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz
mv clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04/ 8.0.0
```

Prepare build system:

```
git clone git@github.com:ShiftLeftSecurity/llvm2cpg.git --recursive
mkdir build
cd build
cmake -G Ninja \
    -DCMAKE_C_COMPILER=clang \
    -DCMAKE_CXX_COMPILER=clang++ \
    -DPATH_TO_LLVM=/opt/llvm/8.0.0 \
    ../llvm2cpg
```

#### Build and run tests:

```
ninja llvm2cpg-tests
./tests/CPGTests/llvm2cpg-tests
```

#### Build and run `cpg-proto-writer`

```
ninja cpg-proto-writer
./tools/cpg-proto-writer/cpg-proto-writer ./tests/fixtures/hello_world/hello_world.bc
```

You should see the following output:

```
Processing ./tests/fixtures/hello_world/hello_world.bc
CPG is successfully save on disk: ./cpg.bin.zip
```

Getting help from `cpg-proto-writer`:

```
./tools/cpg-proto-writer/cpg-proto-writer --help
```

## Testing

LLVM Bitcode is platform specific. In order to write tests against bitcode it is recommended
to compile it on the target (developer) machine.

#### Fixtures

Test harness contains a number of utilities to generate and to use fixtures.
You can find implementation details under `build-system/tests/fixtures.cmake`.

##### Generation of fixtures

From a developer perspective, you only need to know one function: `compile_fixture`.

Here is an example:

```
compile_fixture(
  COMPILER ${CMAKE_C_COMPILER}
  INPUT ${CMAKE_CURRENT_LIST_DIR}/hello_world.c
  OUTPUT_EXTENSION ll
  FLAGS -c -emit-llvm
)
```

This function expands into the following command:

```
${CMAKE_C_COMPILER} -c -emit-llvm ${CMAKE_CURRENT_LIST_DIR}/hello_world.c -o hello_world.ll
```

The fixture will be generated when it is needed by the test target.
The fixture will be re-generated when the contents of the input file changes.

For more examples, please look at `tests/fixtures`.

##### Usage of fixtures

Besides that, it does some bookkeeping under the hood:
 
 - adds the fixture `INPUT` into the global list of fixtures
 - stores input and output files for the given fixture
 - generates a C++ header file containing all the fixture inputs and outputs

The file looks like this:

```
// !!! Autogenerated file !!!

namespace llvm2cpg {
namespace fixtures {

static __attribute__((used)) const char *hello_world_c_bc_output_path() {
  return "/opt/llvm2cpg/cmake-build-debug/tests/fixtures/hello_world/hello_world.bc";
}

static __attribute__((used)) const char *hello_world_c_bc_input_path() {
  return "/opt/llvm2cpg/tests/fixtures/hello_world/hello_world.c";
}

} // namespace fixtures
} // namespace llvm2cpg
```

There are two methods for each fixtures: `<fixture_name>_input_path` and `<fixture_name>_output_path`.
They can be used as follows:

```
llvm::LLVMContext context;
BitcodeLoader loader;
auto bitcode = loader.loadBitcode(fixtures::hello_world_c_bc_output_path(), context);
ASSERT_NE(bitcode.get(), nullptr);
```

##### Fixture naming

The fixture name is a concatenation of the `INPUT` file name and the `OUTPUT_EXTENSION` with all
the dots replaced by underscores. Examples:

 ```
compile_fixture(
  INPUT foo/bar.buzz.c
  OUTPUT_EXTENSION bc
)
=> bar_buzz_c_bc

compile_fixture(
  INPUT foo/bar.buzz.c
  OUTPUT_EXTENSION opt.bc
)
=> bar_buzz_c_opt_bc
```

The fixture names must be unique across the project. Otherwise, you will get an error from CMake.
